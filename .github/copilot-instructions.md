# Copilot Instructions

- **Purpose & scope**: Terraform config provisions portal shared environment pieces: resource group, App Configuration, per-namespace Key Vaults, user-assigned identities, Azure AD app registrations (repository API + integration tests), role assignments, and exports. Everything lives under terraform/.
- **State & providers**: Remote state uses the HCL backends in terraform/backends/*.backend.hcl with OIDC/AzureAD auth; keep Terraform >=1.14.3 with azurerm ~>4.57 and azuread ~>3.0 as pinned in [terraform/providers.tf](terraform/providers.tf#L1-L31).
- **Environments**: dev/prd driven by tfvars in [terraform/tfvars/dev.tfvars](terraform/tfvars/dev.tfvars#L1-L60) and [terraform/tfvars/prd.tfvars](terraform/tfvars/prd.tfvars#L1-L60); these set subscription IDs, tag maps, managed identity definitions, and app_config lists. Match environment strings to labels in App Configuration JSONs.
- **Naming conventions**: Locals define deterministic names for RG/App Config/SQL group and namespaces for repo APIs v1/v2 + integration tests; user-assigned identities are formatted `id-portal-{name_suffix}-{environment}` as built in [terraform/locals.tf](terraform/locals.tf#L1-L71).
- **App Configuration content**: App settings come from JSON descriptors in terraform/app_configs/*.json; they must include `label`, `namespace`, `keys`, optional `secret_keys` (with optional `expiration`). The locals flatten to `config_keys`/`config_secret_keys` consumed by [terraform/app_configuration_key.tf](terraform/app_configuration_key.tf#L1-L108). Add new configs by adding a JSON file and referencing it in the env-specific `app_configs` list.
- **App Configuration store**: Single store per env with local auth disabled and pass-through proxy in [terraform/app_configuration.tf](terraform/app_configuration.tf#L1-L15). Non-secret keys are literal values; secret keys are vault references to the per-namespace Key Vaults; dynamic keys also inject repo API audience/client id/secret for v1/v2 and integration tests.
- **Key Vault strategy**: A Key Vault is created per namespace with randomized names and RBAC enabled in [terraform/key_vault.tf](terraform/key_vault.tf#L1-L32). Static secrets from `secret_keys` use placeholder values and `ignore_changes` so updates happen outside Terraform; dynamic secrets persist AzureAD app creds/tenant IDs in [terraform/key_vault_secret.tf](terraform/key_vault_secret.tf#L1-L73).
- **Managed identities & access**: Identities are defined via the `managed_identities` map variable; optional `app_config_reader` defaults true. Creation lives in [terraform/user_assigned_identity.tf](terraform/user_assigned_identity.tf#L1-L7). Role bindings grant App Configuration Data Reader and Key Vault Secrets User per namespace in [terraform/role_assignments.tf](terraform/role_assignments.tf#L1-L15); include namespaces in the variable to wire KV access.
- **Azure AD applications**: Repository API app registration defines an OAuth2 user_impersonation scope and `ServiceAccount` app role; service principal and rotating password are set in [terraform/application_registration.tf](terraform/application_registration.tf#L1-L55). Integration tests app + secret live in [terraform/application_registration.tf#L56-L78](terraform/application_registration.tf#L56-L78). Password rotation uses 30-day `time_rotating` in [terraform/time_rotating.tf](terraform/time_rotating.tf#L1-L3).
- **SQL admin group**: An Azure AD security group `sql-portal-admins-{env}` is created and populated from `sql_admin_aad_group_members` service principals in [terraform/aad_group.tf](terraform/aad_group.tf#L1-L11) with SP lookups in [terraform/data.service_principals.tf](terraform/data.service_principals.tf#L1-L5).
- **Resource group**: Single RG per env named `rg-portal-environments-{env}-{location}` in [terraform/resource_group.tf](terraform/resource_group.tf#L1-L6); ensure delete protection is disabled via provider features when managing it.
- **Outputs**: Useful IDs for managed identities and SQL admin group plus the App Configuration endpoint are emitted in [terraform/outputs.tf](terraform/outputs.tf#L1-L23) for downstream consumers.
- **Workflows & automation**: GitHub Actions invoke custom `frasermolyneux/actions/*` composites. Feature branches and PRs plan/apply dev; PRs also plan prod (skip for dependabot). Main/release workflow applies dev then prod; destroy workflows exist for dev or a chosen env. See [ .github/workflows/feature-development.yml](.github/workflows/feature-development.yml#L1-L22), [pull-request-validation.yml](.github/workflows/pull-request-validation.yml#L1-L46), [release-to-production.yml](.github/workflows/release-to-production.yml#L1-L43), and destroys in [destroy-development.yml](.github/workflows/destroy-development.yml#L1-L24) and [destroy-environment.yml](.github/workflows/destroy-environment.yml#L1-L30).
- **Running Terraform locally**: Use the matching backend file and var file per env, e.g. `terraform init -backend-config=backends/dev.backend.hcl` then `terraform plan -var-file=tfvars/dev.tfvars` (or prd equivalents). Providers expect AzureAD auth; storage_use_azuread is enabled.
- **App Config JSON example**: repository web API dev shows tenant/instance keys at [terraform/app_configs/repository-webapi-v1-dev.json](terraform/app_configs/repository-webapi-v1-dev.json#L1-L12); mirror label/namespace pairs across envs for consistency.
- **Security scanning**: Microsoft Security DevOps runs on PRs/main via [ .github/workflows/devops-secure-scanning.yml](.github/workflows/devops-secure-scanning.yml#L1-L37); keep SARIF outputs uploading intact when altering workflows.
- **General change safety**: Keep env-specific IDs (subscription/tenant) and tag schema aligned across tfvars; if introducing new namespaces ensure both App Config and Key Vault wiring exist; avoid altering provider versions or backend settings without coordination.
